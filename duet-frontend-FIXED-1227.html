<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DUET by BCAG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            background-color: #000;  /* ÂÖàË®≠ÂÆöÈªëËâ≤ËÉåÊôØÔºåÈÅøÂÖçÁôΩËâ≤ÈñÉÁàç */
            background-image: url('https://raw.githubusercontent.com/brendon-create/duet-openscad/main/images/deskdiamond.jpg');
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .glass {
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px) saturate(100%);
            -webkit-backdrop-filter: blur(10px) saturate(100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37), inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
        }

        #control-panel {
            position: absolute;
            left: 20px;
            top: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            padding: 24px;
            border-radius: 20px;
            z-index: 100;
        }

        #control-panel::-webkit-scrollbar { 
            width: 4px; 
        }
        #control-panel::-webkit-scrollbar-track {
            margin: 20px 0;
        }
        #control-panel::-webkit-scrollbar-thumb { 
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 2px; 
        }

        .panel-header {
            text-align: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-header h1 {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 4px;
        }

        .panel-header .subtitle {
            font-size: 11px;
            color: #d4af37;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 300;
        }

        .section { margin-bottom: 24px; }
        .section-title {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: #d4af37;
            margin-bottom: 16px;
        }

        .control-group { margin-bottom: 16px; }
        label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }

        .flex-row { display: flex; gap: 10px; }
        .flex-row > div:first-child { flex: 1; }
        .flex-row > div:last-child { flex: 2; }

        input[type="text"], select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            background: rgba(255, 255, 255, 0.12);
            border-color: #d4af37;
        }

        .font-select-btn {
            width: 100%;
            padding: 12px 16px;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            color: #d4af37;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        /* Â≠óÈ´î‰∏ãÊãâÈÅ∏ÂñÆ‰∏≠ÁöÑÈÅ∏È†Ö‰ª•ÂêÑËá™Â≠óÈ´îÈ°ØÁ§∫ */
        select.font-select-btn {
            font-family: inherit;
        }
        
        select.font-select-btn option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
            font-size: 14px;
        }

        .font-select-btn:hover {
            background: rgba(212, 175, 55, 0.25);
            border-color: #d4af37;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #d4af37;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(212, 175, 55, 0.4);
        }

        .slider-value {
            float: right;
            color: #d4af37;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #d4af37 0%, #aa8a2e 100%);
            color: #000;
            box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
            display: flex;
            align-items: center;
        }

        #addToCartBtn {
            justify-content: space-between;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .view-cart-section {
            width: 70px;
            border-left: 1px solid rgba(0, 0, 0, 0.2);
            padding-left: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 9px;
            cursor: pointer;
        }

        .view-cart-section:hover {
            opacity: 0.8;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .info-label { color: rgba(255, 255, 255, 0.6); }
        .info-value {
            color: #d4af37;
            font-weight: 600;
            text-align: right;
        }

        #saved-versions {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .version-slot {
            width: 160px;
            height: 160px;
            border-radius: 16px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .version-slot:hover { transform: scale(1.05); }

        .version-slot.empty {
            background: rgba(255, 255, 255, 0.15);
            border: 2px dashed rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .version-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            font-size: 10px;
            text-align: center;
            color: #d4af37;
        }

        #viewport {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
        }

        /* Font Selector Modal */
        #font-selector-modal {
            display: none;
            position: fixed;
            top: 20px;
            left: 360px;
            right: 20px;
            max-height: calc(100vh - 40px);
            border-radius: 16px;
            z-index: 2000;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px) saturate(150%);
            -webkit-backdrop-filter: blur(20px) saturate(150%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37), inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
        }

        #font-selector-modal.active { display: block; }

        .close-modal-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 40px;
            cursor: pointer;
            z-index: 2001;
            width: auto;
            padding: 0;
            line-height: 1;
        }

        .close-modal-btn:hover {
            color: #d4af37;
        }

        .modal-layout {
            display: flex;
            height: calc(100vh - 40px);
        }

        .font-sidebar {
            width: 20%;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.02);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
        }

        .font-sidebar::-webkit-scrollbar { width: 4px; }
        .font-sidebar::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); }

        .char-input-group {
            margin-bottom: 20px;
        }

        .char-input-group input {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            text-align: center;
            font-size: 18px;
            border-radius: 8px;
        }

        .select-all-group {
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .select-all-group input {
            margin-right: 10px;
            cursor: pointer;
        }

        .font-list-item {
            display: flex;
            align-items: center;
            padding: 10px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: background 0.2s;
        }

        .font-list-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .font-list-item input[type="checkbox"] {
            margin-right: 12px;
            cursor: pointer;
        }

        .font-list-item span {
            font-size: 13px;
            color: #ccc;
        }

        .font-display-area {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 20px;
            align-content: start;
        }

        .font-display-area::-webkit-scrollbar { width: 6px; }
        .font-display-area::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

        .font-preview-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid transparent;
            border-radius: 12px;
            transition: all 0.3s;
            cursor: pointer;
            min-height: 140px;
        }

        .font-preview-card:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
        }

        .font-preview-card.selected {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.15);
        }

        .preview-char {
            font-size: 48px;
            margin-bottom: 8px;
            color: #fff;
        }

        .preview-name {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .confirm-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 2002;
        }

        .confirm-btn {
            background: linear-gradient(135deg, #d4af37 0%, #aa8a2e 100%);
            color: #000;
            border: none;
            padding: 16px 40px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
            transition: all 0.3s;
        }

        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* Cart Modal */
        #cart-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #cart-modal.active { display: flex; }

        .cart-container {
            width: 80%;
            max-width: 900px;
            height: 80%;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .cart-header {
            padding: 24px 32px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cart-header h2 {
            font-size: 24px;
            font-weight: 700;
        }

        .cart-items {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .cart-item {
            padding: 20px;
            margin-bottom: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .cart-item-image {
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            flex-shrink: 0;
        }

        .cart-item-info {
            flex: 1;
        }

        .cart-item-info h3 {
            font-size: 18px;
            margin-bottom: 8px;
        }

        .cart-item-details {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
        }

        .cart-item-price {
            font-size: 20px;
            font-weight: 700;
            color: #d4af37;
            margin-right: 20px;
        }

        .cart-item-quantity {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .quantity-input {
            width: 60px;
            padding: 8px;
            text-align: center;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            -moz-appearance: textfield;
        }

        .quantity-input::-webkit-outer-spin-button,
        .quantity-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .quantity-btns {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .qty-btn {
            width: 24px;
            height: 20px;
            padding: 0;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #d4af37;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qty-btn:hover {
            background: rgba(212, 175, 55, 0.3);
        }

        .delete-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.3);
            color: #ff4444;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        .delete-btn:hover {
            background: rgba(255, 0, 0, 0.3);
        }

        .cart-footer {
            padding: 24px 32px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cart-total {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #d4af37;
        }

        .cart-actions {
            display: flex;
            gap: 12px;
        }

        .cart-actions button {
            flex: 1;
            text-align: center;
            justify-content: center;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #d4af37;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            letter-spacing: 3px;
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">LOADING STUDIO...</div>
    </div>

    <div id="viewport"></div>

    <div id="control-panel" class="glass">
        <div class="panel-header">
            <h1>DUET</h1>
            <div class="subtitle">BY BCAG</div>
        </div>

        <div class="section">
            <div class="control-group">
                <label>Letter 1</label>
                <div class="flex-row">
                    <div><select id="letter1"></select></div>
                    <div><button class="font-select-btn" id="font1-btn">Choose Fonts</button></div>
                </div>
            </div>

            <div class="control-group">
                <label>Letter 2</label>
                <div class="flex-row">
                    <div><select id="letter2"></select></div>
                    <div><button class="font-select-btn" id="font2-btn">Choose Fonts</button></div>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <div class="control-group">
            <label>Material</label>
            <select id="material">
                <option value="gold18k">18K Gold</option>
                <option value="whitegold18k">18K White Gold</option>
                <option value="rosegold18k">18K Rose Gold</option>
                <option value="silver925">925 Sterling Silver</option>
                <option value="brass">Brass</option>
                <option value="platinum">Platinum PT950</option>
            </select>
        </div>

        <div class="control-group">
            <label>Texture</label>
            <select id="finish">
                <option value="glossy">Glossy (Mirror Finish)</option>
                <option value="matte">Matte (Brushed)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Size (Height)</label>
            <select id="size">
                <option value="8">8 mm</option>
                <option value="10">10 mm</option>
                <option value="12">12 mm</option>
                <option value="15" selected>15 mm</option>
                <option value="18">18 mm</option>
            </select>
        </div>

        <div class="divider"></div>

        <div class="section-title">Bail Position</div>

        <div class="control-group">
            <label>X (Left/Right) <span class="slider-value" id="bailX-val">0.0</span></label>
            <input type="range" id="bailX" min="-10" max="10" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Y (Front/Back) <span class="slider-value" id="bailY-val">0.0</span></label>
            <input type="range" id="bailY" min="-10" max="10" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Z (Up/Down) <span class="slider-value" id="bailZ-val">0.0</span></label>
            <input type="range" id="bailZ" min="-10" max="10" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Rotation <span class="slider-value" id="bailRotation-val">0¬∞</span></label>
            <input type="range" id="bailRotation" min="0" max="90" step="1" value="0">
        </div>

        <div class="divider"></div>

        <div class="info-box">
            <div class="info-row">
                <span class="info-label">VOLUME</span>
                <span class="info-value" id="volume-display">- mm¬≥</span>
            </div>
            <div class="info-row">
                <span class="info-label">WEIGHT</span>
                <span class="info-value" id="weight-display">- g</span>
            </div>
        </div>

        <!-- Â≠óÈ´îÈ†êËºâÂÖ•ÈÄ≤Â∫¶ÊèêÁ§∫ -->
        <div id="font-preload-status" style="display: none; margin-top: 12px; padding: 12px; background: rgba(212, 175, 55, 0.1); border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 12px; font-size: 11px;">
            <div style="display: flex; align-items: center; gap: 8px; color: #d4af37;">
                <div style="width: 12px; height: 12px; border: 2px solid rgba(212, 175, 55, 0.3); border-top-color: #d4af37; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span id="preload-text">È†êËºâÂÖ•Â≠óÈ´î‰∏≠...</span>
            </div>
            <div style="margin-top: 6px; font-size: 10px; color: rgba(255, 255, 255, 0.5);" id="preload-progress">0 / 0</div>
        </div>

        <button class="btn-secondary" id="save-slot-1">Save to Slot 1</button>
        <button class="btn-secondary" id="save-slot-2">Save to Slot 2</button>
        <button class="btn-primary" id="addToCartBtn">
            <span style="flex: 1;">Add to Cart</span>
            <div class="view-cart-section" id="viewCartBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 2px;">
                    <circle cx="9" cy="21" r="1"/>
                    <circle cx="20" cy="21" r="1"/>
                    <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/>
                </svg>
                <span style="margin-top: 2px;">View Cart</span>
            </div>
        </button>
    </div>

    <div id="saved-versions">
        <div class="version-slot empty" data-slot="1">
            <div class="version-label">SLOT 1</div>
        </div>
        <div class="version-slot empty" data-slot="2">
            <div class="version-label">SLOT 2</div>
        </div>
    </div>

    <!-- Font Selector Modal -->
    <div id="font-selector-modal">
        <button class="close-modal-btn" id="close-modal">√ó</button>
        
        <div class="modal-layout">
            <aside class="font-sidebar">
                <div class="char-input-group">
                    <input type="text" id="char-input" maxlength="2" placeholder="type in 2 letters" value="">
                </div>

                <div class="select-all-group">
                    <input type="checkbox" id="select-all-checkbox">
                    <label for="select-all-checkbox">ÂÖ®ÈÅ∏ / ÂÖ®ÈÉ®ÂèñÊ∂à</label>
                </div>

                <div id="font-list-container"></div>
            </aside>

            <section class="font-display-area" id="font-display-area"></section>
        </div>

        <div class="confirm-container">
            <button class="confirm-btn" id="confirm-btn">Confirm Selection</button>
        </div>
    </div>

    <!-- Cart Modal -->
    <div id="cart-modal">
        <div class="cart-container">
            <div class="cart-header">
                <h2>Shopping Cart</h2>
            </div>
            <div class="cart-items" id="cart-items"></div>
            <div class="cart-footer">
                <div class="cart-total">
                    <span>Total:</span>
                    <span id="cart-total">NT$ 0</span>
                </div>
                <div class="cart-actions">
                    <button class="btn-secondary" id="continue-shopping">Continue Shopping</button>
                    <button class="btn-primary" id="checkout">Checkout</button>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "three-mesh-bvh": "https://esm.sh/three-mesh-bvh@0.7.3",
            "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0,three-mesh-bvh@0.7.3",
            "opentype": "https://esm.sh/opentype.js@1.3.4"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { Evaluator, Brush, INTERSECTION } from 'three-bvh-csg';
        import opentype from 'opentype';

        // ============================================================
        // DUET ÂæåÁ´ØÊï¥Âêà - Ê∑ªÂä†Êñº 2024
        // ============================================================

        // === ÂæåÁ´Ø API Ë®≠ÂÆö ===
        // ===== ÈÖçÁΩÆÂçÄÂ°ä =====
        const TESTING_MODE = true;  // ‚ö†Ô∏è Ê∏¨Ë©¶Ê®°ÂºèÔºå‰∏äÁ∑öÂâçÊîπ false
        const BACKEND_URL = 'https://duet-backend-wlw8.onrender.com';

        console.log('üîß Áï∂ÂâçÈÖçÁΩÆ:', {
            Ê∏¨Ë©¶Ê®°Âºè: TESTING_MODE ? '‚úÖ ÂïüÁî®' : '‚ùå ÈóúÈñâ',
            ÂæåÁ´ØURL: BACKEND_URL
        }); 

        console.log('üîß ÂæåÁ´Ø URL:', BACKEND_URL);

        // === Ê∏¨Ë©¶ÂæåÁ´ØÈÄ£Êé• ===
        async function testBackendConnection() {
            try {
                console.log('üîç Ê∏¨Ë©¶ÂæåÁ´ØÈÄ£Êé•...');
                const response = await fetch(`${BACKEND_URL}/health`, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ ÂæåÁ´ØÈÄ£Êé•ÊàêÂäü:', data);
                
                // È°ØÁ§∫ÊàêÂäüË®äÊÅØÔºàÈÅ∏Áî®Ôºâ
                if (data.engine === 'OpenSCAD') {
                    console.log('‚úÖ OpenSCAD ÂºïÊìéÂ∑≤Â∞±Á∑í');
                }
                
                return true;
            } catch (error) {
                console.error('‚ùå ÂæåÁ´ØÈÄ£Êé•Â§±Êïó:', error);
                console.error('Ë´ãÁ¢∫Ë™çÔºö');
                console.error('1. Á∂≤Ë∑ØÈÄ£Á∑öÊòØÂê¶Ê≠£Â∏∏');
                console.error('2. ÂæåÁ´Ø URL ÊòØÂê¶Ê≠£Á¢∫:', BACKEND_URL);
                return false;
            }
        }

        // È†ÅÈù¢ËºâÂÖ•ÊôÇËá™ÂãïÊ∏¨Ë©¶
        window.addEventListener('load', async () => {
            console.log('üì± È†ÅÈù¢Â∑≤ËºâÂÖ•ÔºåÂàùÂßãÂåñ...');
            
            // ÂÖàÂàùÂßãÂåñÂèØÁî®Â≠óÈ´îÊ∏ÖÂñÆ
            await initAvailableFonts();
            
            // ÁÑ∂ÂæåÊ∏¨Ë©¶ÂæåÁ´ØÈÄ£Êé•
            testBackendConnection();
        });

        // ============================================================
        // ‰ª•‰∏ãÊòØÂéüÂßãÁ®ãÂºèÁ¢º
        // ============================================================

        // ÂÖ®ÂüüËÆäÊï∏
        let scene, camera, renderer, controls, envMap;
        let mainMesh = null, bailMesh = null;
        let loadedFonts = {};
        let checkedFonts = new Set();
        let cartItems = [];
        let savedVersions = [null, null];
        let slot1Scene, slot2Scene, slot1Renderer, slot2Renderer, slot1Camera, slot2Camera;
        let modelTopZ = 0;
        let modelCenter = new THREE.Vector3();

        // 120 Á®ÆÂ≠óÈ´îÊ∏ÖÂñÆÔºà‰æÜËá™ font-selector.htmÔºâ
        // ÂèØÁî®Â≠óÈ´îÊ∏ÖÂñÆÔºàÂ∞áÁî±ÂæåÁ´ØÂãïÊÖãËºâÂÖ•Ôºâ
        let availableFonts = [];
        
        // ÂÆåÊï¥Â≠óÈ´îÊ∏ÖÂñÆÔºàÂâçÁ´ØÂÆöÁæ©Ôºâ
        const allFonts = [
    "Abel", "Abril Fatface", "Advent Pro", "Alegreya", "Alex Brush",
    "Alfa Slab One", "Alice", "Allura", "Amatic SC", "Amiri",
    "Anton", "Arapey", "Archivo", "Armata", "Artifika",
    "Arvo", "Audiowide", "Average", "Baloo 2", "Bangers",
    "Bebas Neue", "Belgrano", "Bentham", "Bitter", "Bree Serif",
    "Bubblegum Sans", "Bungee", "Cabin", "Cantata One", "Caudex",
    "Caveat", "Chivo", "Cinzel", "Comfortaa", "Commissioner",
    "Cookie", "Copse", "Cormorant Garamond", "Courier Prime", "Coustard",
    "Creepster", "Cutive Mono", "DM Serif Text", "Dancing Script", "Dosis",
    "EB Garamond", "Eczar", "Encode Sans", "Fauna One", "Fira Code",
    "Fira Sans", "Fjalla One", "Fugaz One", "Gelasio", "Gloria Hallelujah",
    "Great Vibes", "Handlee", "Hind", "Holtwood One SC", "Inconsolata",
    "Indie Flower", "Jost", "Kalam", "Kanit", "Karla",
    "Lexend", "Lobster", "Merriweather", "Neuton", "Nunito",
    "Old Standard TT", "Orbitron", "Oswald", "Outfit", "Pacifico",
    "Passion One", "Pathway Gothic One", "Patrick Hand", "Paytone One", "Playfair Display",
    "Poppins", "Prata", "Quicksand", "Righteous", "Rubik",
    "Russo One", "Sacramento", "Secular One", "Shadows Into Light", "Share Tech Mono",
    "Shrikhand", "Sniglet", "Space Grotesk", "Space Mono", "Spectral",
    "Tangerine", "Titan One", "Varela Round", "Vollkorn", "Zilla Slab"
];
        
        // ÂàùÂßãÂåñÂèØÁî®Â≠óÈ´îÊ∏ÖÂñÆ
        async function initAvailableFonts() {
            try {
                console.log('üîç Ê≠£Âú®Áç≤ÂèñÂæåÁ´ØÂèØÁî®Â≠óÈ´î...');
                const response = await fetch(`${BACKEND_URL}/list-fonts`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const backendFonts = data.fonts || [];
                
                console.log(`‚úÖ ÂæåÁ´ØÂÖ±Êúâ ${backendFonts.length} Á®ÆÂ≠óÈ´î`);
                
                // ÈÅéÊøæÔºöÂè™‰øùÁïôÂæåÁ´Ø‰πüÊúâÁöÑÂ≠óÈ´î
                availableFonts = allFonts.filter(font => backendFonts.includes(font));
                
                console.log(`‚úÖ ÂâçÂæåÁ´ØÂÖ±ÈÄöÂ≠óÈ´î: ${availableFonts.length} Á®Æ`);
                console.log(`‚ö†Ô∏è ‰∏çÂèØÁî®Â≠óÈ´î: ${allFonts.length - availableFonts.length} Á®Æ`);
                
                if (availableFonts.length === 0) {
                    console.error('‚ùå Ê≤íÊúâÂèØÁî®Â≠óÈ´îÔºÅ');
                    availableFonts = ['Roboto']; // Á∑äÊÄ•ÂÇôÁî®
                }
                
            } catch (error) {
                console.error('‚ùå ÁÑ°Ê≥ïÁç≤ÂèñÂ≠óÈ´îÊ∏ÖÂñÆ:', error);
                // Â¶ÇÊûúÂ§±ÊïóÔºå‰ΩøÁî®ÂÖ®ÈÉ®Â≠óÈ´îÔºà‰øùÊåÅÂéüÊúâË°åÁÇ∫Ôºâ
                availableFonts = allFonts;
            }
        }

        const fonts = allFonts; // ‰øùÊåÅÂêëÂæåÂÖºÂÆπÔºàÁ®çÂæåÊúÉÁßªÈô§Ôºâ

        // ÊùêË≥™Ë®≠ÂÆö
        const MATERIALS = {
            gold18k: { color: 0xFFD700, metalness: 1.0, roughness: { glossy: 0.0, matte: 0.6 }, density: 15.3 },
            whitegold18k: { color: 0xE5E5E5, metalness: 1.0, roughness: { glossy: 0.0, matte: 0.6 }, density: 15.3 },
            rosegold18k: { color: 0xECC5B0, metalness: 1.0, roughness: { glossy: 0.0, matte: 0.6 }, density: 15.0 },
            silver925: { color: 0xC0C0C0, metalness: 1.0, roughness: { glossy: 0.0, matte: 0.6 }, density: 10.3 },
            brass: { color: 0xB5A642, metalness: 0.9, roughness: { glossy: 0.0, matte: 0.6 }, density: 8.5 },
            platinum: { color: 0xE5E5E5, metalness: 1.0, roughness: { glossy: 0.0, matte: 0.6 }, density: 21.4 }
        };

        // ÂàùÂßãÂåñÂ†¥ÊôØÔºàZ-up Á≥ªÁµ±Ôºâ
        function initScene() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.up.set(0, 0, 1); // Z-up Á≥ªÁµ±
            // ÂæûÁâ©‰ª∂ÂâçÊñπÁ®çÂæÆÂÅèÂè≥‰∏äÔºå15Â∫¶‰øØËßíËßÄÁúã 45 Â∫¶Â§æËßí
            camera.position.set(50, -70, 15);  // X=50(Âè≥), Y=-70(Ââç), Z=15(‰∏ä)
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('viewport').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 5, 10);
            scene.add(directionalLight);

            const rgbeLoader = new RGBELoader();
            rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr', 
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    envMap = texture;
                    scene.environment = envMap;
                    showInitialSphere();
                }
            );

            window.addEventListener('resize', onResize);
        }

        function showInitialSphere() {
            const geometry = new THREE.SphereGeometry(7.5, 64, 64);
            const material = getMaterial('gold18k', 'glossy');
            mainMesh = new THREE.Mesh(geometry, material);
            scene.add(mainMesh);
            document.getElementById('loader').style.display = 'none';
        }

        function getMaterial(materialType, finish) {
            const mat = MATERIALS[materialType];
            const roughness = mat.roughness[finish];
            return new THREE.MeshStandardMaterial({
                color: mat.color,
                metalness: mat.metalness,
                roughness: roughness,
                envMap: envMap,
                envMapIntensity: finish === 'glossy' ? 2.0 : 1.0
            });
        }

        // 3D Âª∫Ê®°ÔºàZ-up Á≥ªÁµ±ÔºöXY Ê∞¥Âπ≥Èù¢ÔºåZ Ëª∏Âêë‰∏äÔºâ
        async function generateModel() {
            const l1 = document.getElementById('letter1').value;
            const l2 = document.getElementById('letter2').value;
            
            // Ê™¢Êü•Â≠óÈ´îÊåâÈàïÊàñ‰∏ãÊãâÈÅ∏ÂñÆÊòØÂê¶ÊúâÈÅ∏ÊìáÁöÑÂ≠óÈ´î
            const font1Select = document.getElementById('font1-select');
            const font2Select = document.getElementById('font2-select');
            const font1Btn = document.getElementById('font1-btn');
            const font2Btn = document.getElementById('font2-btn');
            
            const f1Name = font1Select ? font1Select.value : font1Btn.getAttribute('data-selected');
            const f2Name = font2Select ? font2Select.value : font2Btn.getAttribute('data-selected');
            
            console.log('generateModel called:', { l1, l2, f1Name, f2Name }); // Debug
            
            if (!l1 || !l2 || !f1Name || !f2Name || f1Name === 'reselect' || f2Name === 'reselect') {
                console.log('Missing parameters, showing sphere'); // Debug
                if (!mainMesh || mainMesh.geometry.type !== 'SphereGeometry') {
                    showInitialSphere();
                }
                return;
            }

            const targetHeight = parseInt(document.getElementById('size').value);
            
            // Êö´Â≠òËàäÁâ©‰ª∂ÔºåÁ≠âÊñ∞Áâ©‰ª∂ÂâµÂª∫ÂÆåÊàêÂæåÂÜçÁßªÈô§ÔºàÈÅøÂÖçÁï´Èù¢Á©∫ÁôΩÔºâ
            const oldMainMesh = mainMesh;
            const oldBailMesh = bailMesh;

            console.log('Loading fonts...'); // Debug
            // ËºâÂÖ•Â≠óÈ´î
            const f1 = await loadFont(f1Name);
            const f2 = await loadFont(f2Name);
            console.log('Fonts loaded, generating geometry...'); // Debug
            
            const evaluator = new Evaluator();
            const baseMat = new THREE.MeshStandardMaterial();
            
            const depth = targetHeight * 5.0;
            const params = {
                font: null,
                size: 50,
                height: depth,
                curveSegments: 32,  // Â¢ûÂä†Âà∞ 32ÔºàÊõ¥Âπ≥ÊªëÁöÑÊõ≤Á∑öÔºâ
                bevelEnabled: false,  // üîß ÈóúÈñâ bevel ‰ª•Á¢∫‰øùÂâçÂæåÁ´Ø‰∏ÄËá¥
                bevelThickness: 2.0,
                bevelSize: 0.8,
                bevelSegments: 16
            };

            // === Â≠óÊØç 1 (Ê≠£Èù¢)ÔºöÂ∞áÂ≠óÊØçÂπ≥Èù¢Âæû XY ËΩâÂà∞ XZÔºåÊì†Âá∫ÊñπÂêëÂæû Z ËΩâÂà∞ Y ===
            const geo1 = new TextGeometry(l1, { ...params, font: f1 });
            geo1.computeBoundingBox();
            const bbox1 = geo1.boundingBox;
            const actualHeight1 = bbox1.max.y - bbox1.min.y;
            const actualWidth1 = bbox1.max.x - bbox1.min.x;
            
            // üîç Debug: ÂéüÂßãÂ∞∫ÂØ∏Ôºàscale ‰πãÂâçÔºâ
            console.log(`üîç Letter 1 "${l1}" ÂéüÂßãÂ∞∫ÂØ∏ÔºàÂê´ bevelÔºâ:`, {
                width: actualWidth1.toFixed(3) + 'mm',
                height: actualHeight1.toFixed(3) + 'mm',
                depth: (bbox1.max.z - bbox1.min.z).toFixed(3) + 'mm'
            });
            
            const scale1 = targetHeight / actualHeight1;
            console.log(`üîç Letter 1 Á∏ÆÊîæÊØî‰æã: ${scale1.toFixed(4)} (ÁõÆÊ®ôÈ´òÂ∫¶ ${targetHeight}mm)`);
            
            geo1.scale(scale1, scale1, scale1);
            geo1.center();
            
            // ‰øùÂ≠ò Letter 1 ÁöÑ BBox ‰ø°ÊÅØÔºàcenter ‰πãÂæåÔºårotate ‰πãÂâçÔºâ
            geo1.computeBoundingBox();
            const bbox1AfterScale = geo1.boundingBox;
            window.letter1BBox = {
                width: bbox1AfterScale.max.x - bbox1AfterScale.min.x,
                height: bbox1AfterScale.max.y - bbox1AfterScale.min.y,
                depth: bbox1AfterScale.max.z - bbox1AfterScale.min.z,
                offsetX: (bbox1AfterScale.max.x + bbox1AfterScale.min.x) / 2,
                offsetY: (bbox1AfterScale.max.y + bbox1AfterScale.min.y) / 2,
                offsetZ: (bbox1AfterScale.max.z + bbox1AfterScale.min.z) / 2
            };
            
            // === ‰ΩøÁî®ÂÖ®ÂüüËª∏ÊóãËΩâÔºàÊõ¥Ê∏ÖÊô∞„ÄÅÊòìÁ∂≠Ë≠∑Ôºâ===
            // Letter 1: XZ Âπ≥Èù¢ÔºåÊ≤ø Y Ëª∏ extrude
            // Geometry Ê≤íÊúâ rotateOnWorldAxisÔºåÈúÄË¶ÅÁî®ÊóãËΩâÁü©Èô£
            const rotationMatrix1 = new THREE.Matrix4();
            rotationMatrix1.makeRotationX(Math.PI / 2);
            geo1.applyMatrix4(rotationMatrix1);
            
            const brush1 = new Brush(geo1, baseMat);
            brush1.updateMatrixWorld();

            // === Â≠óÊØç 2 (ÂÅ¥Èù¢)ÔºöYZ Âπ≥Èù¢ÔºåÊ≤ø X Ëª∏ extrude ===
            const geo2 = new TextGeometry(l2, { ...params, font: f2 });
            geo2.computeBoundingBox();
            const bbox2 = geo2.boundingBox;
            const actualHeight2 = bbox2.max.y - bbox2.min.y;
            const actualWidth2 = bbox2.max.x - bbox2.min.x;
            
            // üîç Debug: ÂéüÂßãÂ∞∫ÂØ∏Ôºàscale ‰πãÂâçÔºâ
            console.log(`üîç Letter 2 "${l2}" ÂéüÂßãÂ∞∫ÂØ∏ÔºàÂê´ bevelÔºâ:`, {
                width: actualWidth2.toFixed(3) + 'mm',
                height: actualHeight2.toFixed(3) + 'mm',
                depth: (bbox2.max.z - bbox2.min.z).toFixed(3) + 'mm'
            });
            
            const scale2 = targetHeight / actualHeight2;
            console.log(`üîç Letter 2 Á∏ÆÊîæÊØî‰æã: ${scale2.toFixed(4)} (ÁõÆÊ®ôÈ´òÂ∫¶ ${targetHeight}mm)`);
            
            geo2.scale(scale2, scale2, scale2);
            geo2.center();
            
            // ‰øùÂ≠ò Letter 2 ÁöÑ BBox ‰ø°ÊÅØÔºàcenter ‰πãÂæåÔºårotate ‰πãÂâçÔºâ
            geo2.computeBoundingBox();
            const bbox2AfterScale = geo2.boundingBox;
            window.letter2BBox = {
                width: bbox2AfterScale.max.x - bbox2AfterScale.min.x,
                height: bbox2AfterScale.max.y - bbox2AfterScale.min.y,
                depth: bbox2AfterScale.max.z - bbox2AfterScale.min.z,
                offsetX: (bbox2AfterScale.max.x + bbox2AfterScale.min.x) / 2,
                offsetY: (bbox2AfterScale.max.y + bbox2AfterScale.min.y) / 2,
                offsetZ: (bbox2AfterScale.max.z + bbox2AfterScale.min.z) / 2
            };
            
            // === ‰ΩøÁî®ÂÖ®ÂüüËª∏ÊóãËΩâÔºàÊõ¥Ê∏ÖÊô∞„ÄÅÊòìÁ∂≠Ë≠∑Ôºâ===
            // Letter 2: ÂÖàÁπû X Ëª∏ËΩâ 90 Â∫¶ÔºåÂÜçÁπû Z Ëª∏ËΩâ 90 Â∫¶
            const rotationMatrix2X = new THREE.Matrix4();
            rotationMatrix2X.makeRotationX(Math.PI / 2);
            geo2.applyMatrix4(rotationMatrix2X);
            
            const rotationMatrix2Z = new THREE.Matrix4();
            rotationMatrix2Z.makeRotationZ(Math.PI / 2);
            geo2.applyMatrix4(rotationMatrix2Z);
            
            const brush2 = new Brush(geo2, baseMat);
            brush2.updateMatrixWorld();

            console.log('Calculating intersection...'); // Debug
            // Â∏ÉÊûó‰∫§ÈõÜÈÅãÁÆó
            let result = evaluator.evaluate(brush1, brush2, INTERSECTION);
            
            if (result.geometry.attributes.position.count === 0) {
                console.warn('‰∫§ÈõÜÁÇ∫Á©∫');
                return;
            }

            console.log('Fixing geometry...'); // Debug
            // === ‰øÆÂæ©Âπæ‰ΩïÈ´î ===
            result.geometry = result.geometry.toNonIndexed();
            result.geometry.deleteAttribute('normal');
            result.geometry.computeVertexNormals();

            const offset = 0.001;
            const positions = result.geometry.attributes.position;
            const normals = result.geometry.attributes.normal;
            
            for (let i = 0; i < positions.count; i++) {
                const nx = normals.getX(i);
                const ny = normals.getY(i);
                const nz = normals.getZ(i);
                
                positions.setXYZ(
                    i,
                    positions.getX(i) + nx * offset,
                    positions.getY(i) + ny * offset,
                    positions.getZ(i) + nz * offset
                );
            }
            positions.needsUpdate = true;

            result.geometry.computeBoundingBox();
            const bbox = result.geometry.boundingBox;
            
            // ‚úÖ ÁßªÂãïÁâ©‰ª∂Âà∞ÂéüÈªûÔºàËß£Ê±∫Â∞èÁâ©‰ª∂Ë¢´Êà™Êñ∑ÂïèÈ°åÔºâ
            const center = bbox.getCenter(new THREE.Vector3());
            result.geometry.translate(-center.x, -center.y, -center.z);
            
            // ÈáçÊñ∞Ë®àÁÆó BBoxÔºàÁèæÂú®‰∏≠ÂøÉÊáâË©≤Âú®ÂéüÈªûÔºâ
            result.geometry.computeBoundingBox();
            const newBbox = result.geometry.boundingBox;
            modelTopZ = newBbox.max.z; // Êñ∞ÁöÑÈ´òÂ∫¶Ëª∏ÊòØ Z
            modelCenter.copy(newBbox.getCenter(new THREE.Vector3()));
            
            // Ëº∏Âá∫ÂØ¶ÈöõÂ∞∫ÂØ∏
            const modelWidth = newBbox.max.x - newBbox.min.x;
            const modelDepth = newBbox.max.y - newBbox.min.y;
            const modelHeight = newBbox.max.z - newBbox.min.z;
            
            // üîç Debug: ÂÆåÊï¥Âª∫Ê®°‰ø°ÊÅØ
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìê ÂâçÁ´ØÊ∏¨Èáè - Letter 1 BBox (ÂÇ≥Áµ¶ÂæåÁ´Ø):', {
                width: window.letter1BBox.width.toFixed(3) + 'mm',
                height: window.letter1BBox.height.toFixed(3) + 'mm',
                depth: window.letter1BBox.depth.toFixed(3) + 'mm'
            });
            console.log('üìê ÂâçÁ´ØÊ∏¨Èáè - Letter 2 BBox (ÂÇ≥Áµ¶ÂæåÁ´Ø):', {
                width: window.letter2BBox.width.toFixed(3) + 'mm',
                height: window.letter2BBox.height.toFixed(3) + 'mm',
                depth: window.letter2BBox.depth.toFixed(3) + 'mm'
            });
            console.log('üîç Bevel ÂèÉÊï∏:', {
                bevelEnabled: params.bevelEnabled,
                bevelThickness: params.bevelThickness,
                bevelSize: params.bevelSize,
                bevelSegments: params.bevelSegments
            });
            console.log('üìè ÂâçÁ´Ø Model ÊúÄÁµÇÂØ¶ÈöõÂ∞∫ÂØ∏ (CSG ‰∫§ÈõÜÂæå):');
            console.log('  ÂØ¨Â∫¶ (X):', modelWidth.toFixed(3), 'mm');
            console.log('  Ê∑±Â∫¶ (Y):', modelDepth.toFixed(3), 'mm');
            console.log('  È´òÂ∫¶ (Z):', modelHeight.toFixed(3), 'mm');
            console.log('  ‰∏≠ÂøÉÈªû: (', 
                modelCenter.x.toFixed(3), ',', 
                modelCenter.y.toFixed(3), ',', 
                modelCenter.z.toFixed(3), ')');
            console.log('  BBox min: (', 
                newBbox.min.x.toFixed(3), ',', 
                newBbox.min.y.toFixed(3), ',', 
                newBbox.min.z.toFixed(3), ')');
            console.log('  BBox max: (', 
                newBbox.max.x.toFixed(3), ',', 
                newBbox.max.y.toFixed(3), ',', 
                newBbox.max.z.toFixed(3), ')');
            
            result.material = getMaterial(
                document.getElementById('material').value,
                document.getElementById('finish').value
            );

            mainMesh = result;
            scene.add(mainMesh);

            // Êñ∞Áâ©‰ª∂Â∑≤Ê∑ªÂä†ÔºåÁèæÂú®ÂèØ‰ª•ÂÆâÂÖ®ÁßªÈô§ËàäÁâ©‰ª∂
            if (oldMainMesh) {
                scene.remove(oldMainMesh);
                oldMainMesh.geometry?.dispose();
                oldMainMesh.material?.dispose();
            }
            if (oldBailMesh) {
                scene.remove(oldBailMesh);
                oldBailMesh.geometry?.dispose();
                oldBailMesh.material?.dispose();
            }

            console.log('Model generated, creating bail...'); // Debug
            createBail();
            updateVolumeWeight();
            console.log('Generation complete!'); // Debug
        }

        // Âæû opentype.js Â≠óÈ´îËΩâÊèõÁÇ∫ Three.js typeface Ê†ºÂºè
        function convertOpentypeToThreejs(opentypeFont, fontName) {
            const glyphs = {};
            const resolution = 1000;
            const scale = resolution / opentypeFont.unitsPerEm;
            
            // Áç≤ÂèñÊâÄÊúâÈúÄË¶ÅÁöÑÂ≠óÁ¨¶
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            
            for (const char of chars) {
                const glyph = opentypeFont.charToGlyph(char);
                if (!glyph || glyph.index === 0) continue;
                
                // ‰ΩøÁî®ÂéüÂßãÂñÆ‰ΩçÁç≤ÂèñË∑ØÂæëÔºåÁÑ∂ÂæåÊâãÂãïÁ∏ÆÊîæ
                const path = glyph.getPath(0, 0, opentypeFont.unitsPerEm);
                const commands = [];
                
                for (const cmd of path.commands) {
                    switch (cmd.type) {
                        case 'M':
                            commands.push({ type: 'm', args: [cmd.x * scale, cmd.y * scale] });
                            break;
                        case 'L':
                            commands.push({ type: 'l', args: [cmd.x * scale, cmd.y * scale] });
                            break;
                        case 'Q':
                            commands.push({ type: 'q', args: [cmd.x1 * scale, cmd.y1 * scale, cmd.x * scale, cmd.y * scale] });
                            break;
                        case 'C':
                            commands.push({ type: 'b', args: [cmd.x1 * scale, cmd.y1 * scale, cmd.x2 * scale, cmd.y2 * scale, cmd.x * scale, cmd.y * scale] });
                            break;
                        case 'Z':
                            commands.push({ type: 'z', args: [] });
                            break;
                    }
                }
                
                // Â∞á commands ËΩâÊèõÁÇ∫ 'o' Ê†ºÂºèÔºàThree.js typeface Ê†ºÂºèÔºâ
                let o = '';
                for (const cmd of commands) {
                    o += cmd.type;
                    if (cmd.args.length > 0) {
                        o += ' ' + cmd.args.map(n => Math.round(n)).join(' ') + ' ';
                    }
                }
                
                glyphs[char] = {
                    ha: Math.round((glyph.advanceWidth || opentypeFont.unitsPerEm * 0.5) * scale),
                    x_min: Math.round((glyph.xMin || 0) * scale),
                    x_max: Math.round((glyph.xMax || glyph.advanceWidth || opentypeFont.unitsPerEm * 0.5) * scale),
                    o: o.trim()
                };
            }
            
            return {
                glyphs: glyphs,
                familyName: fontName,
                ascender: Math.round(opentypeFont.ascender * scale),
                descender: Math.round(opentypeFont.descender * scale),
                underlinePosition: Math.round((opentypeFont.tables.post?.underlinePosition || -100) * scale),
                underlineThickness: Math.round((opentypeFont.tables.post?.underlineThickness || 50) * scale),
                boundingBox: {
                    xMin: Math.round((opentypeFont.tables.head?.xMin || 0) * scale),
                    yMin: Math.round((opentypeFont.tables.head?.yMin || 0) * scale),
                    xMax: Math.round((opentypeFont.tables.head?.xMax || 1000) * scale),
                    yMax: Math.round((opentypeFont.tables.head?.yMax || 1000) * scale)
                },
                resolution: resolution,
                original_font_information: {
                    format: 0,
                    copyright: '',
                    fontFamily: fontName,
                    fontSubfamily: 'Regular',
                    uniqueID: fontName,
                    fullName: fontName,
                    version: '1.0',
                    postScriptName: fontName.replace(/ /g, '')
                }
            };
        }

        async function loadFont(fontName) {
            if (loadedFonts[fontName]) return loadedFonts[fontName];
            
            const loader = new FontLoader();
            
            console.log(`Loading font: ${fontName}`);
            
            // Â∞áÂ≠óÈ´îÂêçÁ®±ËΩâÊèõÁÇ∫ npm Â•ó‰ª∂ÂêçÁ®±Ê†ºÂºè
            // ‰æãÂ¶ÇÔºö'Playfair Display' -> 'playfair-display'
            const packageName = fontName.toLowerCase().replace(/ /g, '-');
            
            // ÂòóË©¶ÂæûÂ§öÂÄã‰æÜÊ∫êËºâÂÖ•
            const sources = [
                // 1. @compai/font-* Â•ó‰ª∂ (esm.sh CDN)
                `https://esm.sh/@compai/font-${packageName}/data/typefaces/normal-400.json`,
                // 2. components-ai/typefaces GitHub (jsDelivr)
                `https://cdn.jsdelivr.net/gh/components-ai/typefaces/packages/font-${packageName}/data/typefaces/normal-400.json`,
                // 3. 7dir/json-fonts GitHub
                `https://cdn.jsdelivr.net/gh/7dir/json-fonts/Roboto/${fontName.replace(/ /g, '_')}_Regular.json`,
                // 4. emreacar/google-fonts-as-json GitHub  
                `https://cdn.jsdelivr.net/gh/emreacar/google-fonts-as-json/fonts/${fontName.replace(/ /g, '%20')}/regular.json`,
            ];
            
            for (const url of sources) {
                try {
                    console.log(`Trying: ${url}`);
                    const response = await fetch(url);
                    if (response.ok) {
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            const json = await response.json();
                            // Ê™¢Êü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑ typeface Ê†ºÂºè
                            if (json.glyphs || json.data) {
                                const fontData = json.data || json;
                                const font = loader.parse(fontData);
                                loadedFonts[fontName] = font;
                                console.log(`‚úì Loaded ${fontName} from ${url}`);
                                return font;
                            }
                        }
                    }
                } catch (e) {
                    console.log(`‚úó Failed: ${url}`, e.message);
                }
            }
            
            // Â¶ÇÊûú CDN ÈÉΩÂ§±ÊïóÔºåÂòóË©¶Áî® opentype.js Âæû Google Fonts Ëß£Êûê
            try {
                const fontUrlName = fontName.replace(/ /g, '+');
                const cssUrl = `https://fonts.googleapis.com/css?family=${fontUrlName}`;
                
                const cssResponse = await fetch(cssUrl);
                if (cssResponse.ok) {
                    const cssText = await cssResponse.text();
                    const urlMatch = cssText.match(/url\((https:\/\/fonts\.gstatic\.com\/[^)]+)\)/);
                    
                    if (urlMatch) {
                        const fontFileUrl = urlMatch[1];
                        console.log(`Trying Google Fonts: ${fontFileUrl}`);
                        
                        const fontResponse = await fetch(fontFileUrl);
                        if (fontResponse.ok) {
                            const fontBuffer = await fontResponse.arrayBuffer();
                            
                            try {
                                const opentypeFont = opentype.parse(fontBuffer);
                                const typefaceData = convertOpentypeToThreejs(opentypeFont, fontName);
                                const font = loader.parse(typefaceData);
                                loadedFonts[fontName] = font;
                                console.log(`‚úì Loaded ${fontName} via opentype.js`);
                                return font;
                            } catch (parseError) {
                                console.log(`‚úó Parse failed (likely woff2): ${parseError.message}`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.warn(`Failed Google Fonts: ${error.message}`);
            }
            
            // ÊúÄÁµÇÂÇôÁî®Ôºö‰ΩøÁî®È†êË®≠Â≠óÈ´î
            console.warn(`‚ö† Using Helvetiker for: ${fontName}`);
            return new Promise((resolve) => {
                loader.load(
                    'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
                    (font) => resolve(font)
                );
            });
        }

        function createBail() {
            // ÂÖàÁßªÈô§ËàäÁöÑ bailMesh
            if (bailMesh) {
                scene.remove(bailMesh);
                bailMesh.geometry?.dispose();
                bailMesh.material?.dispose();
                bailMesh = null;
            }
            
            if (!mainMesh) return;
            
            const innerRadius = 1.5;   // ÂÖßÁõ¥Âæë 3mm
            const tubeRadius = 0.35;   // ÁÆ°ÂçäÂæë 0.35mmÔºåÁõ¥Âæë 0.7mm
            const geometry = new THREE.TorusGeometry(innerRadius + tubeRadius, tubeRadius, 16, 32);
            
            // Â∞á Torus Âæû XY Âπ≥Èù¢ËΩâÂà∞ XZ Âπ≥Èù¢ (Á´ôÁ´ã)
            geometry.rotateX(Math.PI / 2);
            // ÁπûÊñ∞ÁöÑÈ´òÂ∫¶Ëª∏ Z ÊóãËΩâ 90 Â∫¶
            geometry.rotateZ(Math.PI / 2);
            
            const material = getMaterial(
                document.getElementById('material').value,
                document.getElementById('finish').value
            );
            bailMesh = new THREE.Mesh(geometry, material);
            scene.add(bailMesh);
            
            updateBailPosition();
        }

        function updateBailPosition() {
            if (!bailMesh) return;
            const x = parseFloat(document.getElementById('bailX').value);
            // bailY Â∞çÊáâ UI ÁöÑ Position Y (Depth)
            const y_depth_adj = parseFloat(document.getElementById('bailY').value);
            // bailZ Â∞çÊáâ UI ÁöÑ Position Z (Height)
            const z_height_adj = parseFloat(document.getElementById('bailZ').value);
            const rotation = parseFloat(document.getElementById('bailRotation').value);
            
            const baseZ = modelTopZ + 2.0; // Âú® Z (È´òÂ∫¶) Ëª∏‰∏äÂÆö‰Ωç
            
            // Ë™øÊï¥ÔºöX ‰∏çËÆä, Y Ëª∏ÁÇ∫ modelCenter.y + Ê∑±Â∫¶Ë™øÊï¥, Z Ëª∏ÁÇ∫ baseZ + È´òÂ∫¶Ë™øÊï¥
            bailMesh.position.set(modelCenter.x + x, modelCenter.y + y_depth_adj, baseZ + z_height_adj);
            
            // ÊóãËΩâ‰ª• Z Ëª∏ÁÇ∫Ëª∏ÂøÉ
            bailMesh.rotation.z = (rotation * Math.PI) / 180;
            
            // üîç Debug: Â¢úÈ†≠‰ΩçÁΩÆ
            console.log('üîç Â¢úÈ†≠ÁµïÂ∞ç‰ΩçÁΩÆ:', {
                x: bailMesh.position.x.toFixed(3),
                y: bailMesh.position.y.toFixed(3),
                z: bailMesh.position.z.toFixed(3),
                rotation: rotation + '¬∞'
            });
            console.log('üîç Ê®°Âûã‰∏≠ÂøÉ:', {
                x: modelCenter.x.toFixed(3),
                y: modelCenter.y.toFixed(3),
                z: modelCenter.z.toFixed(3)
            });
            console.log('üîç Ê®°ÂûãÈ†ÇÈÉ® Z:', modelTopZ.toFixed(3));
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }

        // Âè™Êõ¥Êñ∞ÊùêË≥™Ôºå‰∏çÈáçÂª∫Ê®°ÂûãÔºàÂç≥ÊôÇÂàáÊèõÔºÅÔºâ
        function updateMaterial() {
            if (!mainMesh || !bailMesh) return;
            
            const materialType = document.getElementById('material').value;
            const finish = document.getElementById('finish').value;
            const newMaterial = getMaterial(materialType, finish);
            
            // Êõ¥Êèõ‰∏ªÈ´îÂíåÂ¢úÈ†≠ÁöÑÊùêË≥™
            mainMesh.material = newMaterial;
            bailMesh.material = newMaterial.clone();
            
            // Êõ¥Êñ∞ÈáçÈáèÈ°ØÁ§∫ÔºàÂØÜÂ∫¶ÊîπËÆä‰∫ÜÔºâ
            updateVolumeWeight();
        }

        function updateVolumeWeight() {
            if (!mainMesh || !mainMesh.geometry.attributes.position) {
                document.getElementById('volume-display').textContent = '- mm¬≥';
                document.getElementById('weight-display').textContent = '- g';
                return;
            }

            let volume = 0;
            const positions = mainMesh.geometry.attributes.position;
            const p1 = new THREE.Vector3();
            const p2 = new THREE.Vector3();
            const p3 = new THREE.Vector3();

            for (let i = 0; i < positions.count; i += 3) {
                p1.fromBufferAttribute(positions, i);
                p2.fromBufferAttribute(positions, i + 1);
                p3.fromBufferAttribute(positions, i + 2);
                volume += p1.dot(p2.cross(p3)) / 6.0;
            }
            volume = Math.abs(volume);

            const density = MATERIALS[document.getElementById('material').value].density;
            const weight = (volume * density) / 1000;

            document.getElementById('volume-display').textContent = `${volume.toFixed(2)} mm¬≥`;
            document.getElementById('weight-display').textContent = `${weight.toFixed(2)} g`;
        }

        // Â≠óÈ´îÈÅ∏ÊìáÂô®
        function initFontSelector() {
            const listContainer = document.getElementById('font-list-container');
            const displayArea = document.getElementById('font-display-area');

            // ‰ΩøÁî®Á∂ìÈÅéÂæåÁ´ØÈ©óË≠âÁöÑÂ≠óÈ´îÊ∏ÖÂñÆ
            const fontsToDisplay = availableFonts.length > 0 ? availableFonts : allFonts;
            
            fontsToDisplay.forEach((font) => {
                const item = document.createElement('div');
                item.className = 'font-list-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.dataset.font = font;
                
                const label = document.createElement('span');
                label.textContent = font;
                label.style.fontFamily = `"${font}", sans-serif`;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                listContainer.appendChild(item);
                
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        checkedFonts.add(font);
                    } else {
                        checkedFonts.delete(font);
                    }
                    updateFontDisplay();
                });
                
                item.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });

                const card = document.createElement('div');
                card.className = 'font-preview-card';
                card.dataset.font = font;
                
                const charDiv = document.createElement('div');
                charDiv.className = 'preview-char';
                charDiv.style.fontFamily = `"${font}", sans-serif`;
                // ‰ΩøÁî®Ëº∏ÂÖ•ÁöÑÂâçÂÖ©ÂÄãÂ≠óÊØçÔºåÈ†êË®≠ÁÇ∫ 'A'
                const charInput = document.getElementById('char-input');
                charDiv.textContent = charInput.value.substring(0, 2) || 'A';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'preview-name';
                nameDiv.textContent = font;
                
                card.appendChild(charDiv);
                card.appendChild(nameDiv);
                displayArea.appendChild(card);
                
                card.addEventListener('click', () => {
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event('change'));
                });
            });

            document.getElementById('char-input').addEventListener('input', (e) => {
                // È°ØÁ§∫ÂâçÂÖ©ÂÄãÂ≠óÊØç
                const chars = e.target.value.substring(0, 2) || 'A';
                document.querySelectorAll('.preview-char').forEach(el => {
                    el.textContent = chars;
                });
            });

            document.getElementById('select-all-checkbox').addEventListener('change', (e) => {
                const checkboxes = document.querySelectorAll('.font-list-item input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = e.target.checked;
                    if (e.target.checked) {
                        checkedFonts.add(cb.dataset.font);
                    } else {
                        checkedFonts.delete(cb.dataset.font);
                    }
                });
                updateFontDisplay();
            });
        }

        function updateFontDisplay() {
            document.querySelectorAll('.font-preview-card').forEach(card => {
                const font = card.dataset.font;
                if (checkedFonts.has(font)) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }

        function openFontSelector() {
            // ËÆÄÂèñÁï∂ÂâçÂ≠óÊØç‰∏¶Ëá™ÂãïÂ°´ÂÖ•Â≠óÈ´îÈÅ∏ÊìáË¶ñÁ™ó
            const letter1 = document.getElementById('letter1').value;
            const letter2 = document.getElementById('letter2').value;
            const charInput = document.getElementById('char-input');
            charInput.value = letter1 + letter2;
            
            // Ëß∏Áôº input ‰∫ã‰ª∂ÔºåÊõ¥Êñ∞Â≠óÈ´îÈ†êË¶Ω
            charInput.dispatchEvent(new Event('input'));
            
            document.getElementById('font-selector-modal').classList.add('active');
        }

        function closeFontSelector() {
            document.getElementById('font-selector-modal').classList.remove('active');
        }

        // È†êËºâÂÖ•ÈÅ∏‰∏≠ÁöÑÂ≠óÈ´îÂà∞ cacheÔºàËÉåÊôØËºâÂÖ•Ôºâ
        async function preloadSelectedFonts(fontNames) {
            console.log(`üöÄ ÈñãÂßãÈ†êËºâÂÖ• ${fontNames.length} ÂÄãÂ≠óÈ´î...`);
            
            // È°ØÁ§∫ÈÄ≤Â∫¶ÊèêÁ§∫
            const statusDiv = document.getElementById('font-preload-status');
            const progressText = document.getElementById('preload-progress');
            const preloadText = document.getElementById('preload-text');
            
            statusDiv.style.display = 'block';
            preloadText.textContent = 'È†êËºâÂÖ•Â≠óÈ´î‰∏≠...';
            progressText.textContent = `0 / ${fontNames.length}`;
            
            const startTime = Date.now();
            let successCount = 0;
            
            // ‰∏¶Ë°åËºâÂÖ•ÊâÄÊúâÂ≠óÈ´îÔºà‰∏çÈòªÂ°û UIÔºâ
            const loadPromises = fontNames.map(async (fontName) => {
                try {
                    await loadFont(fontName);
                    successCount++;
                    progressText.textContent = `${successCount} / ${fontNames.length}`;
                    console.log(`‚úì È†êËºâÂÖ•ÊàêÂäü: ${fontName} (${successCount}/${fontNames.length})`);
                } catch (error) {
                    console.warn(`‚úó È†êËºâÂÖ•Â§±Êïó: ${fontName}`, error);
                }
            });
            
            // ‰∏çÁ≠âÂæÖÂÖ®ÈÉ®ÂÆåÊàêÔºåËÆìÂÆÉÂú®ËÉåÊôØÂü∑Ë°å
            Promise.all(loadPromises).then(() => {
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`‚úÖ Â≠óÈ´îÈ†êËºâÂÖ•ÂÆåÊàêÔºÅÊàêÂäü: ${successCount}/${fontNames.length}ÔºåËÄóÊôÇ: ${duration}Áßí`);
                
                // È°ØÁ§∫ÂÆåÊàêÁãÄÊÖã 2 ÁßíÂæåÈö±Ëóè
                preloadText.textContent = `‚úì ${successCount} ÂÄãÂ≠óÈ´îÂ∑≤Â∞±Á∑íÔºÅ`;
                progressText.textContent = `ÂàáÊèõÂ≠óÈ´îÂ∞áÊõ¥Âø´ÈÄü`;
                
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            });
        }

        function confirmFontSelection() {
            if (checkedFonts.size === 0) {
                alert('Please select at least one font!');
                return;
            }

            const inputChars = document.getElementById('char-input').value.trim();
            if (inputChars.length < 2) {
                alert('Please enter 2 letters');
                return;
            }

            const letter1Select = document.getElementById('letter1');
            const letter2Select = document.getElementById('letter2');
            
            letter1Select.value = inputChars[0];
            letter2Select.value = inputChars[1];

            const selectedFonts = Array.from(checkedFonts);
            
            // Êõ¥Êñ∞Â≠óÈ´îÊåâÈàïÁÇ∫‰∏ãÊãâÈÅ∏ÂñÆ
            ['font1', 'font2'].forEach(target => {
                const btn = document.getElementById(`${target}-btn`);
                
                // Èö±ËóèÊåâÈàïÔºåÂâµÂª∫‰∏ãÊãâÈÅ∏ÂñÆ
                btn.style.display = 'none';
                
                // Ê™¢Êü•ÊòØÂê¶Â∑≤Êúâ‰∏ãÊãâÈÅ∏ÂñÆ
                let select = document.getElementById(`${target}-select`);
                if (!select) {
                    select = document.createElement('select');
                    select.id = `${target}-select`;
                    select.className = 'font-select-btn';
                    select.style.display = 'block';
                    select.style.cursor = 'pointer';
                    btn.parentNode.appendChild(select);
                } else {
                    select.style.display = 'block';
                }
                
                // Ê∏ÖÁ©∫‰∏¶Â°´ÂÖ•Â≠óÈ´îÈÅ∏È†Ö
                select.innerHTML = '';
                selectedFonts.forEach(font => {
                    const option = document.createElement('option');
                    option.value = font;
                    option.textContent = font;
                    option.style.fontFamily = `"${font}", sans-serif`;
                    select.appendChild(option);
                });
                
                // Ê∑ªÂä† Re-select ÈÅ∏È†Ö
                const reselectOption = document.createElement('option');
                reselectOption.value = 'reselect';
                reselectOption.textContent = '‚Üª Re-select Fonts';
                select.appendChild(reselectOption);
                
                // ÈÅ∏ÊìáÁ¨¨‰∏ÄÂÄãÂ≠óÈ´îÔºå‰∏¶Ë®≠ÁΩÆ‰∏ãÊãâÈÅ∏ÂñÆÁöÑÂ≠óÈ´îÊ®£Âºè
                select.value = selectedFonts[0];
                btn.setAttribute('data-selected', selectedFonts[0]);
                select.style.fontFamily = `"${selectedFonts[0]}", sans-serif`;
                
                // Áõ£ËÅΩ‰∏ãÊãâÈÅ∏ÂñÆËÆäÊõ¥
                select.onchange = function() {
                    if (this.value === 'reselect') {
                        openFontSelector();
                        this.value = btn.getAttribute('data-selected') || selectedFonts[0];
                    } else {
                        btn.setAttribute('data-selected', this.value);
                        // Êõ¥Êñ∞‰∏ãÊãâÈÅ∏ÂñÆÊú¨Ë∫´ÁöÑÂ≠óÈ´îÊ®£Âºè
                        this.style.fontFamily = `"${this.value}", sans-serif`;
                        // ‰∏çÂêåÊ≠•Êõ¥Êñ∞Âè¶‰∏ÄÂÄã‰∏ãÊãâÈÅ∏ÂñÆÔºåÂÖÅË®±Áç®Á´ãÈÅ∏Êìá
                        generateModel();
                    }
                };
            });

            closeFontSelector();
            
            // üöÄ È†êËºâÂÖ•ÊâÄÊúâÈÅ∏‰∏≠ÁöÑÂ≠óÈ´îÂà∞ cacheÔºàËÉåÊôØËºâÂÖ•Ôºâ
            preloadSelectedFonts(selectedFonts);
            
            generateModel();
        }

        // ÊßΩ‰ΩçÂäüËÉΩÔºàÁ∞°ÂåñÁâàÔºöÁ¥îÂÑ≤Â≠òÂíåÂè¨ÂõûÔºåÊ∑ªÂä†ÂêåÊ≠•ÊóãËΩâÔºâ
        function saveToSlot(slotIndex) {
            if (!mainMesh) return;
            
            const slotElement = document.querySelector(`[data-slot="${slotIndex + 1}"]`);
            slotElement.classList.remove('empty');
            
            // Áç≤ÂèñÁï∂ÂâçÂ≠óÈ´îÂêçÁ®±
            const font1Select = document.getElementById('font1-select');
            const font2Select = document.getElementById('font2-select');
            const font1Name = font1Select ? font1Select.value : document.getElementById('font1-btn').getAttribute('data-selected');
            const font2Name = font2Select ? font2Select.value : document.getElementById('font2-btn').getAttribute('data-selected');
            
            // ‰øùÂ≠òÁï∂ÂâçÁãÄÊÖã
            savedVersions[slotIndex] = {
                letter1: document.getElementById('letter1').value,
                letter2: document.getElementById('letter2').value,
                font1: font1Name,
                font2: font2Name,
                material: document.getElementById('material').value,
                finish: document.getElementById('finish').value,
                size: document.getElementById('size').value,
                bailX: document.getElementById('bailX').value,
                bailY: document.getElementById('bailY').value,
                bailZ: document.getElementById('bailZ').value,
                bailRotation: document.getElementById('bailRotation').value,
                mesh: mainMesh.clone(),
                bail: bailMesh ? bailMesh.clone() : null
            };
            
            // ÂâµÂª∫Á∏ÆÁï•Âúñ
            slotElement.innerHTML = '';
            const canvas = document.createElement('canvas');
            canvas.width = 160;
            canvas.height = 160;
            slotElement.appendChild(canvas);
            
            const slotRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            slotRenderer.setSize(160, 160);
            slotRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            slotRenderer.outputColorSpace = THREE.SRGBColorSpace;
            
            const slotScene = new THREE.Scene();
            const slotCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            slotCamera.up.set(0, 0, 1); // Z-up Á≥ªÁµ±
            const dist = 50;
            const ratioX = 1.0;
            const ratioY = 0.4;
            const ratioZ = 1.0;
            const totalRatio = Math.sqrt(ratioX * ratioX + ratioY * ratioY + ratioZ * ratioZ);
            const scaleFactor = dist / totalRatio;
            const newRatioX = ratioZ;
            const newRatioY = -ratioX;
            slotCamera.position.set(
                newRatioX * scaleFactor,
                newRatioY * scaleFactor,
                ratioY * scaleFactor
            );
            slotCamera.lookAt(0, 0, 0);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.5);
            const light2 = new THREE.DirectionalLight(0xffffff, 1.0);
            light2.position.set(5, 5, 10);
            slotScene.add(light1);
            slotScene.add(light2);
            slotScene.environment = envMap;
            
            const meshClone = mainMesh.clone();
            slotScene.add(meshClone);
            if (bailMesh) {
                const bailClone = bailMesh.clone();
                slotScene.add(bailClone);
            }
            
            slotRenderer.render(slotScene, slotCamera);
            
            // ‰øùÂ≠òÂà∞ÂÖ®ÂüüËÆäÊï∏‰ª•‰æøÂêåÊ≠•ÊóãËΩâ
            if (slotIndex === 0) {
                slot1Renderer = slotRenderer;
                slot1Scene = slotScene;
                slot1Camera = slotCamera;
            } else {
                slot2Renderer = slotRenderer;
                slot2Scene = slotScene;
                slot2Camera = slotCamera;
            }
            
            const label = document.createElement('div');
            label.className = 'version-label';
            label.textContent = `SLOT ${slotIndex + 1}`;
            slotElement.appendChild(label);
        }

        function loadFromSlot(slotIndex) {
            const slotData = savedVersions[slotIndex];
            if (!slotData) return;
            
            // ËºâÂÖ•ÊßΩ‰ΩçÊï∏ÊìöÂà∞‰∏ªÁï´Èù¢
            document.getElementById('letter1').value = slotData.letter1;
            document.getElementById('letter2').value = slotData.letter2;
            document.getElementById('material').value = slotData.material;
            document.getElementById('finish').value = slotData.finish;
            document.getElementById('size').value = slotData.size;
            document.getElementById('bailX').value = slotData.bailX;
            document.getElementById('bailY').value = slotData.bailY;
            document.getElementById('bailZ').value = slotData.bailZ;
            document.getElementById('bailRotation').value = slotData.bailRotation;
            
            // Êõ¥Êñ∞È°ØÁ§∫ÂÄº
            document.getElementById('bailX-val').textContent = slotData.bailX;
            document.getElementById('bailY-val').textContent = slotData.bailY;
            document.getElementById('bailZ-val').textContent = slotData.bailZ;
            document.getElementById('bailRotation-val').textContent = slotData.bailRotation + '¬∞';
            
            // Êõ¥Êñ∞Â≠óÈ´îÊåâÈàïÂíå‰∏ãÊãâÈÅ∏ÂñÆ
            const font1Btn = document.getElementById('font1-btn');
            const font2Btn = document.getElementById('font2-btn');
            font1Btn.setAttribute('data-selected', slotData.font1);
            font2Btn.setAttribute('data-selected', slotData.font2);
            
            const font1Select = document.getElementById('font1-select');
            const font2Select = document.getElementById('font2-select');
            if (font1Select) font1Select.value = slotData.font1;
            if (font2Select) font2Select.value = slotData.font2;
            
            // Ê∏ÖÈô§ËàäÊ®°Âûã
            if (mainMesh) {
                scene.remove(mainMesh);
                if (mainMesh.geometry) mainMesh.geometry.dispose();
                if (mainMesh.material) mainMesh.material.dispose();
            }
            if (bailMesh) {
                scene.remove(bailMesh);
                if (bailMesh.geometry) bailMesh.geometry.dispose();
                if (bailMesh.material) bailMesh.material.dispose();
            }
            
            // ËºâÂÖ•Êñ∞Ê®°ÂûãÔºà‰ΩøÁî®Ê∑±Êã∑Ë≤ùÔºâ
            mainMesh = slotData.mesh.clone();
            mainMesh.material = mainMesh.material.clone();
            scene.add(mainMesh);
            
            if (slotData.bail) {
                bailMesh = slotData.bail.clone();
                bailMesh.material = bailMesh.material.clone();
                scene.add(bailMesh);
            }
            
            updateVolumeWeight();
        }

        // Ë≥ºÁâ©Ëªä
        function addToCart() {
            if (!mainMesh) return;
            
            // ‚úÖ ÈôêÂà∂Ë≥ºÁâ©ËªäÊúÄÂ§ö 3 ÂÄãÁâ©‰ª∂
            if (cartItems.length >= 3) {
                alert('Ë≥ºÁâ©ËªäÊúÄÂ§öÂè™ËÉΩÂä†ÂÖ• 3 ÂÄãÂïÜÂìÅ\nÂ¶ÇÈúÄË®ÇË≥ºÊõ¥Â§öÔºåË´ãÂàÜÊâπÁµêÂ∏≥');
                return;
            }
            
            // Áç≤ÂèñÁï∂ÂâçÈÅ∏ÊìáÁöÑÂ≠óÈ´îÂêçÁ®±
            const font1Select = document.getElementById('font1-select');
            const font2Select = document.getElementById('font2-select');
            const font1Name = font1Select ? font1Select.value : document.getElementById('font1-btn').getAttribute('data-selected');
            const font2Name = font2Select ? font2Select.value : document.getElementById('font2-btn').getAttribute('data-selected');
            
            // Ë®àÁÆóÂ¢úÈ†≠Áõ∏Â∞çÊñº‰∏ªÈ´î‰∏≠ÂøÉÁöÑÂêëÈáè
            const bailRelativeX = bailMesh ? (bailMesh.position.x - modelCenter.x) : 0;
            const bailRelativeY = bailMesh ? (bailMesh.position.y - modelCenter.y) : 0;
            const bailRelativeZ = bailMesh ? (bailMesh.position.z - modelCenter.z) : 0;
            const bailRot = bailMesh ? (bailMesh.rotation.z * 180 / Math.PI) : 0;
            
            const item = {
                id: Date.now(),
                letter1: document.getElementById('letter1').value,
                letter2: document.getElementById('letter2').value,
                font1: font1Name,
                font2: font2Name,
                material: document.getElementById('material').value,
                size: parseInt(document.getElementById('size').value),  // ‚úÖ ËΩâÊèõÁÇ∫Êï¥Êï∏
                volume: document.getElementById('volume-display').textContent,
                weight: document.getElementById('weight-display').textContent,
                quantity: 1,
                price: 5000,
                // ÂÑ≤Â≠òÂ¢úÈ†≠Áõ∏Â∞çÂêëÈáè
                bailRelativeX: bailRelativeX,
                bailRelativeY: bailRelativeY,
                bailRelativeZ: bailRelativeZ,
                bailRotation: bailRot,
                // ÂÑ≤Â≠òÂ¢úÈ†≠ÁµïÂ∞çÂ∫ßÊ®ôÔºàÁî®ÊñºÂæåÁ´ØÁ≤æÁ¢∫ÂÆö‰ΩçÔºâ
                bailAbsoluteX: bailMesh ? bailMesh.position.x : 0,
                bailAbsoluteY: bailMesh ? bailMesh.position.y : 0,
                bailAbsoluteZ: bailMesh ? bailMesh.position.z : 0,
                // ÂÑ≤Â≠òÂ≠óÊØç BBox ‰ø°ÊÅØÔºàÁî®ÊñºÂæåÁ´ØÁ≤æÁ¢∫Âª∫Ê®°Ôºâ
                letter1BBox: window.letter1BBox || {},
                letter2BBox: window.letter2BBox || {}
                // ‚úÖ ‰∏çÂÜçÂÑ≤Â≠ò mesh Âíå bailÔºàÈÅøÂÖçÂÇ≥ÈÄÅÂ∑®Â§ßÁâ©‰ª∂Ôºâ
            };
            
            cartItems.push(item);
            openCart();
        }

        function openCart() {
            document.getElementById('cart-modal').classList.add('active');
            renderCart();
        }

        function closeCart() {
            document.getElementById('cart-modal').classList.remove('active');
        }

        function renderCart() {
            const container = document.getElementById('cart-items');
            
            if (cartItems.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.4); padding: 40px;">Your cart is empty</div>';
                document.getElementById('cart-total').textContent = 'NT$ 0';
                return;
            }

            container.innerHTML = '';
            let total = 0;

            cartItems.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'cart-item';
                
                // ÂâµÂª∫ 3D Á∏ÆÁï•Âúñ
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                canvas.className = 'cart-item-image';
                
                const thumbnailRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                thumbnailRenderer.setSize(100, 100);
                thumbnailRenderer.toneMapping = THREE.ACESFilmicToneMapping;
                thumbnailRenderer.outputColorSpace = THREE.SRGBColorSpace;
                
                const thumbnailScene = new THREE.Scene();
                const thumbnailCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                thumbnailCamera.up.set(0, 0, 1);  // Z-up
                thumbnailCamera.position.set(20, -28, 6);  // ‰ΩøÁî®‰∏ªÁõ∏Ê©üËßíÂ∫¶
                thumbnailCamera.lookAt(0, 0, 0);
                
                // Ê∑ªÂä†ÁáàÂÖâ
                const light1 = new THREE.AmbientLight(0xffffff, 0.5);
                const light2 = new THREE.DirectionalLight(0xffffff, 1.0);
                light2.position.set(5, 5, 10);
                thumbnailScene.add(light1);
                thumbnailScene.add(light2);
                
                // Â¶ÇÊûúÊúâ‰∏ªÂ†¥ÊôØ‰∏≠ÁöÑÊ®°ÂûãÔºåË§áË£ΩÂÆÉ
                if (item.mesh) {
                    thumbnailScene.add(item.mesh.clone());
                    if (item.bail) thumbnailScene.add(item.bail.clone());
                }
                
                thumbnailRenderer.render(thumbnailScene, thumbnailCamera);
                
                div.appendChild(canvas);
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'cart-item-info';
                infoDiv.innerHTML = `
                    <h3>DUET "${item.letter1}${item.letter2}"</h3>
                    <div class="cart-item-details">
                        "${item.letter1}" in font "${item.font1}"<br>
                        "${item.letter2}" in font "${item.font2}"<br>
                        Material: ${item.material}<br>
                        Size: ${item.size}mm | Weight: ${item.weight}
                    </div>
                `;
                div.appendChild(infoDiv);
                
                const priceDiv = document.createElement('div');
                priceDiv.className = 'cart-item-price';
                priceDiv.textContent = `NT$ ${(item.price * item.quantity).toLocaleString()}`;
                div.appendChild(priceDiv);
                
                const quantityDiv = document.createElement('div');
                quantityDiv.className = 'cart-item-quantity';
                
                const quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.className = 'quantity-input';
                quantityInput.value = item.quantity;
                quantityInput.min = '1';
                quantityInput.setAttribute('data-index', index);
                quantityInput.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value) || 1;
                    if (value > 0) {
                        cartItems[index].quantity = value;
                        renderCart();
                    }
                });
                
                const quantityBtns = document.createElement('div');
                quantityBtns.className = 'quantity-btns';
                
                const upBtn = document.createElement('button');
                upBtn.className = 'qty-btn';
                upBtn.textContent = '‚ñ≤';
                upBtn.onclick = () => {
                    cartItems[index].quantity++;
                    renderCart();
                };
                
                const downBtn = document.createElement('button');
                downBtn.className = 'qty-btn';
                downBtn.textContent = '‚ñº';
                downBtn.onclick = () => {
                    if (cartItems[index].quantity > 1) {
                        cartItems[index].quantity--;
                        renderCart();
                    }
                };
                
                quantityBtns.appendChild(upBtn);
                quantityBtns.appendChild(downBtn);
                
                quantityDiv.appendChild(quantityInput);
                quantityDiv.appendChild(quantityBtns);
                div.appendChild(quantityDiv);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '√ó';
                deleteBtn.onclick = () => {
                    cartItems.splice(index, 1);
                    renderCart();
                };
                div.appendChild(deleteBtn);
                
                container.appendChild(div);
                total += item.price * item.quantity;
            });

            document.getElementById('cart-total').textContent = `NT$ ${total.toLocaleString()}`;
        }

  async function testModeCheckout() {
    console.log('üß™ Ê∏¨Ë©¶Ê®°ÂºèÔºöÊ®°Êì¨ÊîØ‰ªòÊàêÂäü');
    
    const mockOrderId = 'TEST_' + Date.now();
    const mockUserInfo = {
        name: 'Ê∏¨Ë©¶Áî®Êà∂',
        email: 'brendon@brendonchen.com',
        phone: '0912345678'
    };
    
    try {
        console.log('üì§ ÁôºÈÄÅÊ∏¨Ë©¶Ë®ÇÂñÆÂà∞ÂæåÁ´Ø...');
        
        // ‚úÖ ÊéíÈô§ mesh Âíå bailÔºà3D Áâ©‰ª∂ÔºâÔºåÂè™ÁôºÈÄÅÂøÖË¶ÅË≥áÊñô
        const itemsWithBBox = cartItems.map(item => {
            // Ëß£ÊßãÊéíÈô§ mesh Âíå bail
            const {mesh, bail, ...itemData} = item;
            
            return {
                ...itemData,
                // ‚úÖ Á¢∫‰øùÊâÄÊúâÊï∏ÂÄºÊ¨Ñ‰ΩçÈÉΩÊòØÊï∏Â≠óÈ°ûÂûã
                size: typeof item.size === 'string' ? parseInt(item.size) : item.size,
                quantity: typeof item.quantity === 'string' ? parseInt(item.quantity) : item.quantity,
                price: typeof item.price === 'string' ? parseFloat(item.price) : item.price,
                bailAbsoluteX: typeof item.bailAbsoluteX === 'string' ? parseFloat(item.bailAbsoluteX) : (item.bailAbsoluteX || 0),
                bailAbsoluteY: typeof item.bailAbsoluteY === 'string' ? parseFloat(item.bailAbsoluteY) : (item.bailAbsoluteY || 0),
                bailAbsoluteZ: typeof item.bailAbsoluteZ === 'string' ? parseFloat(item.bailAbsoluteZ) : (item.bailAbsoluteZ || 0),
                bailRelativeX: typeof item.bailRelativeX === 'string' ? parseFloat(item.bailRelativeX) : (item.bailRelativeX || 0),
                bailRelativeY: typeof item.bailRelativeY === 'string' ? parseFloat(item.bailRelativeY) : (item.bailRelativeY || 0),
                bailRelativeZ: typeof item.bailRelativeZ === 'string' ? parseFloat(item.bailRelativeZ) : (item.bailRelativeZ || 0),
                bailRotation: typeof item.bailRotation === 'string' ? parseFloat(item.bailRotation) : (item.bailRotation || 0),
                letter1BBox: item.letter1BBox || {width: 10, height: 12, depth: 5, offsetX: 0, offsetY: 0, offsetZ: 0},
                letter2BBox: item.letter2BBox || {width: 10, height: 12, depth: 5, offsetX: 0, offsetY: 0, offsetZ: 0}
            };
        });
        
        console.log('üì¶ Ë®ÇÂñÆË≥áÊñô:', {orderId: mockOrderId, items: itemsWithBBox, total: calculateCartTotal()});
        
        const response = await fetch(`${BACKEND_URL}/api/test-order`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                orderId: mockOrderId,
                items: itemsWithBBox,
                userInfo: mockUserInfo,
                total: calculateCartTotal(),
                testMode: true
            })
        });
        
        console.log('üì• Êî∂Âà∞ÂõûÊáâ:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå ÂæåÁ´ØÈåØË™§:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ ÂæåÁ´ØÂõûÊáâ:', result);
        
        if (result.success) {
            cartItems = [];
            renderCart();
            closeCart();
            showSuccessModal();
            console.log('‚úÖ Ê∏¨Ë©¶Ë®ÇÂñÆÂÆåÊàêÔºÅ');
        } else {
            alert('‚ùå Ê∏¨Ë©¶Â§±ÊïóÔºö' + (result.error || 'Êú™Áü•ÈåØË™§'));
        }
        
    } catch (error) {
        console.error('‚ùå Ê∏¨Ë©¶Ê®°ÂºèÈåØË™§:', error);
        alert('‚ùå ÈÄ£Êé•ÂæåÁ´ØÂ§±ÊïóÔºö\n\n' + error.message + '\n\nË´ãÊü•Áúã Console ‰∫ÜËß£Ë©≥ÊÉÖ');
    }
}

function showSuccessModal() {
    // ÁßªÈô§ËàäÁöÑÂΩàÁ™ó
    const oldModal = document.getElementById('success-modal');
    if (oldModal) {
        oldModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'success-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 99999;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        max-width: 360px;
        padding: 30px 35px;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(20px) saturate(150%);
        -webkit-backdrop-filter: blur(20px) saturate(150%);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37), inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
        text-align: center;
    `;
    
    content.innerHTML = `
        <h3 style="
            margin: 0 0 12px 0;
            color: #fff;
            font-size: 20px;
            font-weight: 500;
            letter-spacing: 0.5px;
        ">ÁµêÂ∏≥ÂÆåÊàê</h3>
        <p style="
            margin: 0 0 24px 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            line-height: 1.5;
        ">ÊÑüË¨ùÊÇ®ÁöÑË®ÇË≥º<br>Á¢∫Ë™ç‰ø°Â∑≤ÁôºÈÄÅËá≥‰ø°ÁÆ±</p>
        <button id="success-ok-btn" style="
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        ">Á¢∫ÂÆö</button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // ÊåâÈàïÊá∏ÂÅúÊïàÊûú
    const btn = document.getElementById('success-ok-btn');
    btn.onmouseover = () => {
        btn.style.background = 'rgba(255, 255, 255, 0.15)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
    };
    btn.onmouseout = () => {
        btn.style.background = 'rgba(255, 255, 255, 0.1)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.2)';
    };
    
    // ‚úÖ ÈªûÊìäÁ¢∫ÂÆöÔºöÈóúÈñâ‰∏¶ÂÆåÊï¥ÈáçÁΩÆÂ†¥ÊôØ
    btn.onclick = () => {
        modal.remove();
        
        // 1. ÁßªÈô§ËàäÁöÑ mesh
        if (mainMesh) {
            scene.remove(mainMesh);
            mainMesh.geometry?.dispose();
            mainMesh.material?.dispose();
            mainMesh = null;
        }
        if (bailMesh) {
            scene.remove(bailMesh);
            bailMesh.geometry?.dispose();
            bailMesh.material?.dispose();
            bailMesh = null;
        }
        
        // 2. Ê∏ÖÁ©∫Ëº∏ÂÖ•
        document.getElementById('letter1').value = '';
        document.getElementById('letter2').value = '';
        
        // 3. ÈáçÁΩÆÂ≠óÈ´îÊåâÈàï
        const font1Btn = document.getElementById('font1-btn');
        const font2Btn = document.getElementById('font2-btn');
        if (font1Btn) {
            font1Btn.setAttribute('data-selected', 'reselect');
            font1Btn.textContent = 'ÈÅ∏ÊìáÂ≠óÈ´î';
        }
        if (font2Btn) {
            font2Btn.setAttribute('data-selected', 'reselect');
            font2Btn.textContent = 'ÈÅ∏ÊìáÂ≠óÈ´î';
        }
        
        // 4. È°ØÁ§∫ÈáëËâ≤ÁêÉÈ´î
        showInitialSphere();
    };
    
    // ÈªûÊìäËÉåÊôØÈóúÈñâÔºàÂêåÊ®£Ëß∏ÁôºÈáçÁΩÆÔºâ
    modal.onclick = (e) => {
        if (e.target === modal) {
            btn.click();
        }
    };
}

// ‰∏ªÁµêÂ∏≥ÂáΩÊï∏ÔºàÊ†πÊìöÊ∏¨Ë©¶Ê®°ÂºèÊ±∫ÂÆöÊµÅÁ®ãÔºâ
function checkout() {
    if (TESTING_MODE) {
        testModeCheckout();
    } else {
        processPayment();
    }
}
        
        // Ê≠£Â∏∏ÊîØ‰ªòÊµÅÁ®ã
        async function processPayment() {
            console.log('üí≥ ÈñãÂßãÊîØ‰ªòÊµÅÁ®ã...');
            
            // Êî∂ÈõÜÁî®Êà∂Ë≥áË®ä
            const userInfo = await getUserInfo();
            if (!userInfo) {
                return; // Áî®Êà∂ÂèñÊ∂à
            }
            
            const orderId = 'DUET_' + Date.now();
            const total = calculateCartTotal();
            
            try {
                // ÂëºÂè´ÂæåÁ´ØÂàùÂßãÂåñÊîØ‰ªò
                const response = await fetch(`${BACKEND_URL}/api/checkout`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderId: orderId,
                        items: cartItems,
                        userInfo: userInfo,
                        total: total,
                        returnUrl: window.location.origin + '/payment-success.html'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // È°ØÁ§∫Á∂†ÁïåÊîØ‰ªòË°®ÂñÆ
                    displayPaymentForm(result.paymentFormHTML);
                } else {
                    alert('‚ùå ÁµêÂ∏≥Â§±ÊïóÔºö' + result.error);
                }
                
            } catch (error) {
                console.error('ÊîØ‰ªòÈåØË™§:', error);
                alert('‚ùå ÊîØ‰ªòÈÅéÁ®ãÁôºÁîüÈåØË™§Ôºö' + error.message);
            }
        }
        
        // Ë®àÁÆóË≥ºÁâ©ËªäÁ∏ΩÈáëÈ°ç
        function calculateCartTotal() {
            return cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        }
        
        // Êî∂ÈõÜÁî®Êà∂Ë≥áË®ä
        async function getUserInfo() {
            return new Promise((resolve) => {
                // ÂâµÂª∫Ë°®ÂñÆ modal
                const modal = document.createElement('div');
                modal.id = 'user-info-modal';
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px;">
                        <h2 style="margin-bottom: 20px;">Â°´ÂØ´Ë®ÇË≥ºË≥áË®ä</h2>
                        <form id="user-info-form">
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px;">ÂßìÂêç *</label>
                                <input type="text" id="user-name" required 
                                       style="width: 100%; padding: 10px; border: 1px solid rgba(255,255,255,0.2); 
                                              background: rgba(255,255,255,0.1); color: white; border-radius: 5px;">
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px;">Email *</label>
                                <input type="email" id="user-email" required
                                       style="width: 100%; padding: 10px; border: 1px solid rgba(255,255,255,0.2); 
                                              background: rgba(255,255,255,0.1); color: white; border-radius: 5px;">
                            </div>
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 5px;">ÊâãÊ©üËôüÁ¢º *</label>
                                <input type="tel" id="user-phone" required pattern="[0-9]{10}"
                                       placeholder="0912345678"
                                       style="width: 100%; padding: 10px; border: 1px solid rgba(255,255,255,0.2); 
                                              background: rgba(255,255,255,0.1); color: white; border-radius: 5px;">
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button type="submit" class="btn" style="flex: 1;">
                                    ÁπºÁ∫å‰ªòÊ¨æ
                                </button>
                                <button type="button" class="btn" style="flex: 1; background: rgba(255,255,255,0.1);" 
                                        onclick="document.getElementById('user-info-modal').remove();">
                                    ÂèñÊ∂à
                                </button>
                            </div>
                        </form>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // ËôïÁêÜË°®ÂñÆÊèê‰∫§
                document.getElementById('user-info-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    
                    const userInfo = {
                        name: document.getElementById('user-name').value.trim(),
                        email: document.getElementById('user-email').value.trim(),
                        phone: document.getElementById('user-phone').value.trim()
                    };
                    
                    modal.remove();
                    resolve(userInfo);
                });
            });
        }
        
        // È°ØÁ§∫Á∂†ÁïåÊîØ‰ªòË°®ÂñÆ
        function displayPaymentForm(formHTML) {
            // ÂâµÂª∫ÈÅÆÁΩ©Â±§
            const overlay = document.createElement('div');
            overlay.id = 'payment-overlay';
            overlay.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                            background: rgba(0,0,0,0.9); z-index: 10000; 
                            display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 40px; border-radius: 15px; 
                                max-width: 500px; text-align: center;">
                        <h2 style="color: #333; margin-bottom: 15px;">Ë∑≥ËΩâËá≥Á∂†ÁïåÊîØ‰ªò...</h2>
                        <p style="color: #666; margin-bottom: 20px;">Ë´ãÁ®çÂÄôÔºåÊ≠£Âú®ÁÇ∫ÊÇ®Â∞éÂêëÊîØ‰ªòÈ†ÅÈù¢</p>
                        <div style="width: 50px; height: 50px; border: 5px solid #f3f3f3; 
                                    border-top: 5px solid #3498db; border-radius: 50%; 
                                    animation: spin 1s linear infinite; margin: 0 auto;"></div>
                        ${formHTML}
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(overlay);
            
            // Ëá™ÂãïÊèê‰∫§Ë°®ÂñÆ
            setTimeout(() => {
                const form = overlay.querySelector('form');
                if (form) {
                    console.log('üîÑ Ëá™ÂãïÊèê‰∫§Á∂†ÁïåË°®ÂñÆ...');
                    form.submit();
                }
            }, 1500);
        }

        // ‰∫ã‰ª∂Áõ£ËÅΩ
        function setupEventListeners() {
            // ÂàùÂßãÂåñÂ≠óÊØçÈÅ∏ÂñÆ
            const letter1 = document.getElementById('letter1');
            const letter2 = document.getElementById('letter2');
            
            for (let i = 65; i <= 90; i++) {
                letter1.add(new Option(String.fromCharCode(i), String.fromCharCode(i)));
                letter2.add(new Option(String.fromCharCode(i), String.fromCharCode(i)));
            }
            for (let i = 97; i <= 122; i++) {
                letter1.add(new Option(String.fromCharCode(i), String.fromCharCode(i)));
                letter2.add(new Option(String.fromCharCode(i), String.fromCharCode(i)));
            }

            document.getElementById('font1-btn').addEventListener('click', openFontSelector);
            document.getElementById('font2-btn').addEventListener('click', openFontSelector);
            document.getElementById('close-modal').addEventListener('click', closeFontSelector);
            document.getElementById('confirm-btn').addEventListener('click', confirmFontSelection);

            // ÁµêÊßãÂèÉÊï∏ÊîπËÆä ‚Üí ÈáçÂª∫Ê®°Âûã
            ['letter1', 'letter2', 'size'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    generateModel();
                });
            });

            // ÊùêË≥™ÂèÉÊï∏ÊîπËÆä ‚Üí Âè™Êõ¥Êñ∞ÊùêË≥™Ôºå‰∏çÈáçÂª∫Ê®°ÂûãÔºàÂç≥ÊôÇÔºÅÔºâ
            ['material', 'finish'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    updateMaterial();
                });
            });

            ['bailX', 'bailY', 'bailZ', 'bailRotation'].forEach(id => {
                const slider = document.getElementById(id);
                slider.addEventListener('input', (e) => {
                    const suffix = id === 'bailRotation' ? '¬∞' : '';
                    document.getElementById(`${id}-val`).textContent = e.target.value + suffix;
                    // Âè™Êõ¥Êñ∞‰ΩçÁΩÆÔºå‰∏çÈáçÊñ∞ÂâµÂª∫
                    updateBailPosition();
                });
            });

            document.getElementById('save-slot-1').addEventListener('click', () => saveToSlot(0));
            document.getElementById('save-slot-2').addEventListener('click', () => saveToSlot(1));
            
            // Slot ÈªûÊìäÂè¨Âõû
            document.querySelector('[data-slot="1"]').addEventListener('click', () => {
                if (savedVersions[0]) loadFromSlot(0);
            });
            document.querySelector('[data-slot="2"]').addEventListener('click', () => {
                if (savedVersions[1]) loadFromSlot(1);
            });
            document.getElementById('addToCartBtn').addEventListener('click', (e) => {
                // Â¶ÇÊûúÈªûÊìäÁöÑÊòØ View Cart ÂçÄÂüüÔºåÂè™ÊâìÈñãË≥ºÁâ©Ëªä
                if (e.target.id === 'viewCartBtn' || e.target.closest('#viewCartBtn')) {
                    openCart();
                } else {
                    // Âê¶ÂâáÊòØ Add to Cart
                    addToCart();
                }
            });
            document.getElementById('continue-shopping').addEventListener('click', closeCart);
            document.getElementById('checkout').addEventListener('click', checkout);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // ÂêåÊ≠• Slot Áõ∏Ê©ü‰ΩçÁΩÆÂíåÊ∏≤Êüì
            if (slot1Camera && slot1Renderer && slot1Scene) {
                slot1Camera.position.copy(camera.position).multiplyScalar(0.5); // Á∏ÆÊîæË∑ùÈõ¢
                slot1Camera.lookAt(0, 0, 0);
                slot1Renderer.render(slot1Scene, slot1Camera);
            }
            if (slot2Camera && slot2Renderer && slot2Scene) {
                slot2Camera.position.copy(camera.position).multiplyScalar(0.5); // Á∏ÆÊîæË∑ùÈõ¢
                slot2Camera.lookAt(0, 0, 0);
                slot2Renderer.render(slot2Scene, slot2Camera);
            }
            
            renderer.render(scene, camera);
        }

        // ÂïüÂãï
        initScene();
        initFontSelector();
        setupEventListeners();
        animate();

        // ËºâÂÖ• Google Fonts - ÂàÜÊâπËºâÂÖ•ÊâÄÊúâÂ≠óÈ´î
        function loadGoogleFonts() {
            // ÂàÜÊâπËºâÂÖ•ÔºåÊØèÊâπ50ÂÄãÂ≠óÈ´îÔºàÈÅøÂÖçURLÈÅéÈï∑Ôºâ
            const batchSize = 50;
            for (let i = 0; i < fonts.length; i += batchSize) {
                const batch = fonts.slice(i, i + batchSize);
                const link = document.createElement('link');
                link.href = 'https://fonts.googleapis.com/css2?family=' + batch.map(f => f.replace(/ /g, '+')).join('&family=') + '&display=swap';
                link.rel = 'stylesheet';
                document.head.appendChild(link);
            }
        }
        loadGoogleFonts();
    </script>
</body>
</html>
